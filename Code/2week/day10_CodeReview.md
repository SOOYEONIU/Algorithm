# 첫 번째 코드리뷰 회고 👩🏻‍💻
내가 발표한 코드 : [day8_18258](https://github.com/SOOYEONIU/CodingTest/blob/main/Code/2week/day8_18258.js)

## 📍 리뷰 과정
1. **간단한 문제 설명**  
  : 정수를 저장하는 큐를 구현한 다음, 입력으로 여섯가지 명령(push, pop, size, empty, front, back)울 처리하는 프로그램 작성하기 

2. **사용한 자료구조와 알고리즘**  
  : 처음 배열로 Queue를 설계해보았지만, 시간초과 결과를 얻었고 여러 시도 끝에 linked list의 자료구조를 활용하여 Queue를 설계하였다.
    

4. **코드 리뷰**
## 📍 새로 알게 된 내용  
- **Linked list와 Array의 시간 복잡도 및 Queue 구현**  
  배열의 메소드 경우 push, pop, shift, unshift 등이 있는데 stack의 경우 push, pop을 사용하게 되고 Queue의 경우 push, shift를 사용하게 된다.
  우선 배열은 값이 연속된 메모리 주소를 할당 받기 때문에 데이터가 인덱스를 가지게 되는데 push나 pop의 경우 배열의 뒤에서 데이터 추가나 삭제가 이루어지는 것이기 때문에 배열 속 다른 데이터들의 인덱스에 영향을 주지 않는다.


  예를 들면, let array = [1, 2, 3, 4, 5]; 배열이 있으면 각자 데이터 별로 인덱스를 가지게 되죠. 그리고 array.pop();을 실행하여 맨 뒤 데이터를 제거한다고 했을 때
  배열에 [1, 2, 3, 4]가 남게 되고 이 데이터들의 인덱스 값은 변함이 없죠! 따라서 push와 pop의 시간복잡도는 O(1)이 된다.

  그리고 shift와 unshift의 경우 배열의 앞에서 데이터를 구하거나 삭제하는 것이기 때문에 0번째 인덱스가 삭제되었으면 남아있던 데이터들의 인덱스가 한칸씩 밀리게되면서 모든 데이터들의 인덱스에 변화가 생긴다.
  이것도 예를 들면, let array = [1, 2, 3, 4, 5]; 배열에 array.shift();를 실행하여 맨 앞에 데이터를 삭제하게 되니까 배열엔 [2, 3, 4, 5]가 남게 되고 2의 인덱스는 0, 3의 인덱스는 1, 4의 인덱스는 2, 5의 인덱스는 3이 되며 모든 배열의 인덱스에 영향을 준다고 볼 수 있다. 따라서 shift나 unshift의 시간복잡도는 O(n)이 된다.

  저희가 풀었던 백준 문제는 18258번인데 해당 문제에 보면 첫 줄에 입력값의 길이를 주어지는데 (1<= n <= 100,000)이기 때문에 만약 배열 안에 데이터 값이 100,000개인 상황에서 shift를 동작한다고 하였을 때 99,999개의 데이터들의 인덱스가 변경되어야 되니 시간초과가 결과로 뜨게 되는 것이다.
  따라서 linked list는 node로 메모리 주소를 가리키는 것이기 때문에 맨 앞의 값이 삭제되거나 삽입이 되어도 뒤에 연결 되어 있는 node들이 영향을 받지 않기 때문에 시간초과를 해결할 수 있다.
  [블로그 정리](https://sootech-story.tistory.com/entry/JavaScript-Queue-%EA%B5%AC%ED%98%84-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B0%B1%EC%A4%80-18258%EB%B2%88)

## 📍 회고
처음으로 백준 알고리즘 문제를 풀면서 코드 리뷰하였다. 같이 취업 준비하고, 알고리즘 공부하는 개발자들의 코드를 함께 리뷰하고 서로 개선점, 궁금한 점을 함께 이야기하며 흥미롭기도 하고 배울점이 많았다. 그리고 내가 겪었던 어려움을 다른 개발자분들도 겪었다고 말하면서 공감이 되는 부분도 있었다.   

리뷰할 때 팀원들에게 틀린 부분을 잘 못 전달하고, 설명이 어려워지는 부분이 있을까봐 헷갈렸던 부분에 대해 다시 한번 찾아보면서 개념 정리를 확실하게 할 수 있었다.   

스터디를 통해 다른 개발자들의 코드를 볼 수 있고, 미처 생각하지 못했던 부분을 알 수 있는 기회이기에 배울점 많은 시간이였다.
