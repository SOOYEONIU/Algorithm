# 두 번째 코드리뷰 회고 👩🏻‍💻
내가 발표한 코드 : [day8_18258](https://github.com/SOOYEONIU/CodingTest/blob/main/Code/2week/day8_18258.js)

## 📍 리뷰 과정
1. **간단한 문제 설명**  
  : 정수를 저장하는 큐를 구현한 다음, 입력으로 여섯가지 명령(push, pop, size, empty, front, back)울 처리하는 프로그램 작성하기 

2. **사용한 자료구조와 알고리즘**  
  : 처음 배열로 Queue를 설계해보았지만, 시간초과 결과를 얻었고 여러 시도 끝에 linked list의 자료구조를 활용하여 Queue를 설계하였다.
    

4. **코드 리뷰**
## 📍 새로 알게 된 내용  
- **Linked list와 Array의 시간 복잡도 및 Queue 구현**  
  배열의 메소드 경우 push, pop, shift, unshift 등이 있는데 stack의 경우 push, pop을 사용하게 되고 Queue의 경우 push, shift를 사용하게 된다.
  우선 배열은 값이 연속된 메모리 주소를 할당 받기 때문에 데이터가 인덱스를 가지게 되는데 push나 pop의 경우 배열의 뒤에서 데이터 추가나 삭제가 이루어지는 것이기 때문에 배열 속 다른 데이터들의 인덱스에 영향을 주지 않는다.


  예를 들면, `let array = [1, 2, 3, 4, 5];` 배열이 있으면 각자 데이터 별로 인덱스를 가지게 되죠. 그리고 `array.pop();`을 실행하여 맨 뒤 데이터를 제거한다고 했을 때
  배열에 `[1, 2, 3, 4]`가 남게 되고 이 데이터들의 인덱스 값은 변함이 없죠! 따라서 push와 pop의 시간복잡도는 O(1)이 된다.

  그리고 shift와 unshift의 경우 배열의 앞에서 데이터를 구하거나 삭제하는 것이기 때문에 0번째 인덱스가 삭제되었으면 남아있던 데이터들의 인덱스가 한칸씩 밀리게되면서 모든 데이터들의 인덱스에 변화가 생긴다.
  이것도 예를 들면, `let array = [1, 2, 3, 4, 5];` 배열에 `array.shift();`를 실행하여 맨 앞에 데이터를 삭제하게 되니까 배열엔 `[2, 3, 4, 5]`가 남게 되고 2의 인덱스는 0, 3의 인덱스는 1, 4의 인덱스는 2, 5의 인덱스는 3이 되며 모든 배열의 인덱스에 영향을 준다고 볼 수 있다. 따라서 shift나 unshift의 시간복잡도는 O(n)이 된다.

  해당 문제에 보면 첫 줄에 입력값의 길이를 주어지는데 (1<= n <= 100,000)이기 때문에 만약 배열 안에 데이터 값이 100,000개인 상황에서 shift를 동작한다고 하였을 때 99,999개의 데이터들의 인덱스가 변경되어야 되니 시간초과가 결과로 뜨게 되는 것이다.
  따라서 linked list는 node로 메모리 주소를 가리키는 것이기 때문에 맨 앞의 값이 삭제되거나 삽입이 되어도 뒤에 연결 되어 있는 node들이 영향을 받지 않기 때문에 시간초과를 해결할 수 있다.

  [블로그 정리](https://sootech-story.tistory.com/entry/JavaScript-Queue-%EA%B5%AC%ED%98%84-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B0%B1%EC%A4%80-18258%EB%B2%88)


- **.at()메서드**  
  간단하게 음수 인덱스를 사용할 수 있는 메서드이다.

  at() 메서드 정수 값을 받아, 배열에 해당 값에 해당하는 인덱스 요소를 반환한다. 양수와 음수 모두 지정할 수 있고, 음수 값의 경우 배열의 뒤에서부터 인덱스를 센다.

  배열의 맨 마지막 요소를 가져오고 싶을 때 length 속성을 이용해 `array[array.length - 1]`을 하는 대신, 짧게 `array.at(-1)`을 사용할 수 있다.


- **new Map**  
  Map이란 다양한 자료형의 key를 허용하고, key-value 형태의 자료형으로 주어진 collection이다. Object와 비교해 다양한 key사용이 가능하다. 다양한 메서드를 통해 값을 추가 삭제할 수 이다.

  Object와 비교해 . or [] 를 할 필요없이 의도를 명확히 드러낸 메서드를 사용해서 접근, 수정, 삭제등을 할 수 있다. Object는 크기를 keys나 valuse등을 통해 우회해서 확인할 수 있으나, Map은 size 메서드를 통해 쉽게 확인할 수 있다.
  ```javascript
    const map = new Map(); // Map 생성
    console.log(map); // Map(0) {}

    let map2 = new Map(
      ['name', 'kimsooyeon'],
      ['age', 28]
    );
  ```
  - Map 메서드
      - 요소 추가 : Map.set(key, value)
      - 요소 접근 : Map.get(key)
      - 요소 전체 삭제 : Map.clear()
      - 요소 존재 확인 : Map.has(key)
      - 요소 갯수 확인 : Map.size
      - 요소 일부 삭제 : Map.delete(key)

## 📍 회고
못 풀었던 문제를 팀원들의 코드 설명 및 접근 방식을 보며 다양한 접근 방식을 볼 수 있었고, 새로운 메서드 등을 알 수 있었습니다.

팀원에게 코드를 설명하면서 정확하게 설명하지 못했던 부분들에 대해 다시 한번 찾아보고 정리 및 공유를 통해 팀원과 함께 이해하려 노력하였습니다.

서로의 코드를 보며 궁금한 부분, 개선 사항, 다른 접근법을 함께 생각하고 의논할 수 있었기에 오늘도 유익한 코드 리뷰 시간이 되었습니다.
